<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Madias Creek Hydrologic Model & Uncertainty Dashboard</title>
  
  <!-- Chart.js (for Raw, Percentage, Trend tabs) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
  
  <!-- React, ReactDOM, Babel (for Distribution tab) -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  
  <!-- Add prop-types dependency for Recharts -->
  <script src="https://unpkg.com/prop-types@15.6/prop-types.min.js"></script> 
  
  <!-- Recharts (for Distribution tab) - Switched to jsDelivr CDN -->
  <script src="https://cdn.jsdelivr.net/npm/recharts@2.12.7/umd/Recharts.min.js"></script>
  
  <!-- Babel (must be after React/Recharts) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Tailwind CSS (via CDN for styling consistency with React component) -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  
  <style>
    /* Define CSS variables for consistent theming */
    :root {
      --primary-color: #0056b3;          /* Blue (Current scenario) */
      --secondary-color: #17a2b8;        /* Teal (Replant scenario) */
      --accent-color-orange: #fd7e14;    /* Orange (Baseline scenario) */
      --accent-color-red: #dc3545;       /* Red (Urban scenario) */
      --background: #f5f7fa;
      --card-bg: #ffffff;
      --text-color: #343a40;
      --text-secondary: #6c757d;
      --border-light: rgba(0,0,0,0.08);
      --shadow-sm: 0 2px 8px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 15px rgba(0,0,0,0.07);
      --shadow-lg: 0 10px 25px rgba(0,0,0,0.08);
      --transition-fast: 0.2s ease;
      --transition-medium: 0.3s ease;
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 15px;
    }
    
    /* Base styles */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background-color: var(--background);
      color: var(--text-color);
      line-height: 1.6;
      font-size: 16px;
    }
    
    .header {
      background: linear-gradient(135deg, #0d47a1, #1976d2, #2196f3);
      color: white;
      padding: 2rem 1rem;
      text-align: center;
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }
    
    .header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5z' fill='%23ffffff' fill-opacity='0.05' fill-rule='evenodd'/%3E%3C/svg%3E");
      opacity: 0.3;
    }
    
    .header h1 {
      margin-bottom: 0.5rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      font-size: 2.2rem;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .header p {
      max-width: 800px;
      margin: 0 auto;
      opacity: 0.9;
      font-size: 1rem;
      font-weight: 300;
    }
    
    .container {
      max-width: 1200px;
      margin: 2.5rem auto;
      padding: 2.5rem;
      background-color: var(--card-bg);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
    }
    
    .tab-links {
      display: flex;
      flex-wrap: wrap;
      border-bottom: 1px solid var(--border-light);
      margin-bottom: 2.5rem;
      padding-bottom: 0.25rem;
      gap: 0.25rem;
    }
    
    .tab-link {
      padding: 0.875rem 1.25rem;
      cursor: pointer;
      background-color: transparent;
      border: none;
      border-radius: var(--radius-sm) var(--radius-sm) 0 0;
      margin-right: 0.5rem;
      margin-bottom: -1px; /* Overlap border */
      transition: all var(--transition-medium);
      position: relative;
      color: var(--text-secondary);
      font-size: 1rem;
      font-weight: 500;
      user-select: none;
    }
    
    .tab-link.active {
      background-color: rgba(25, 118, 210, 0.05);
      color: var(--primary-color);
      font-weight: 600;
    }
    
    .tab-link.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      width: 100%;
      height: 3px;
      background: linear-gradient(90deg, var(--primary-color), #42a5f5);
      border-radius: 3px 3px 0 0;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from { transform: scaleX(0.6); opacity: 0.6; }
      to { transform: scaleX(1); opacity: 1; }
    }
    
    .tab-link:hover:not(.active) {
      background-color: rgba(0,0,0,0.03);
      color: var(--text-color);
    }
    
    .tab-content {
      display: none;
      background-color: var(--card-bg);
      padding: 2.5rem;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      margin-bottom: 2.5rem;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
    }
    
    .tab-content.active {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }
    
    .tab-content h2 {
      color: var(--primary-color);
      border-bottom: 2px solid var(--border-light);
      padding-bottom: 0.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-size: 1.75rem;
      font-weight: 600;
    }
    
    .chart-container {
      position: relative; /* Needed for Chart.js responsiveness */
      height: 400px;
      width: 100%;
      margin-bottom: 2rem;
      background-color: var(--card-bg);
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-sm);
      padding: 1.5rem;
      border: 1px solid var(--border-light);
      transition: box-shadow var(--transition-medium);
    }
    
    .chart-container:hover {
      box-shadow: var(--shadow-md);
    }
    
    .info-box {
      background-color: rgba(33, 150, 243, 0.05);
      padding: 1.25rem;
      border-left: 4px solid var(--primary-color);
      border-radius: var(--radius-sm);
      margin-bottom: 1.75rem;
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-medium);
    }
    
    .info-box:hover {
      background-color: rgba(33, 150, 243, 0.08);
      box-shadow: 0 3px 12px rgba(0,0,0,0.05);
    }
    
    /* Plot description styling (from 2nd file) */
    .plot-description {
      font-size: 1em;
      color: #495057;
      margin-bottom: 1.5rem;
      background-color: #eef2f7;
      padding: 1.25rem;
      border-radius: var(--radius-sm);
      border-left: 5px solid var(--primary-color);
    }
    
    .plot-description ul {
      margin-top: 0.75rem;
      margin-bottom: 0.5rem;
      padding-left: 1.5rem;
    }
    
    .plot-description li {
      margin-bottom: 0.5rem;
    }
    
    /* Data source note styling (from 2nd file) */
    .data-source-note {
      font-size: 0.9em;
      color: var(--text-secondary);
      margin-top: -0.5rem;
      margin-bottom: 1.5rem;
      font-style: italic;
      font-weight: 500;
      background-color: #fffadf;
      padding: 0.3rem 0.75rem;
      border-radius: 3px;
      display: inline-block;
    }
    
    .footer {
      background: linear-gradient(to right, #111827, #1f2937);
      color: #cbd5e1;
      padding: 2.5rem 1rem;
      text-align: center;
      margin-top: 3rem;
      box-shadow: 0 -1px 5px rgba(0,0,0,0.05);
    }
    
    .footer p {
      max-width: 600px;
      margin: 0 auto;
      opacity: 0.9;
    }
    
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.75rem;
    }
    
    @media (min-width: 768px) {
      .grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    .card {
      background-color: var(--card-bg);
      padding: 1.75rem;
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition-medium), box-shadow var(--transition-medium);
      border: 1px solid var(--border-light);
    }
    
    .card:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-md);
    }
    
    /* Section divider from 2nd file */
    .section-divider {
      border: 0;
      height: 1px;
      background-image: linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,0.1), rgba(0,0,0,0));
      margin: 3rem 0;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      border-radius: var(--radius-sm);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      margin-bottom: 1.5rem;
    }
    
    table th, table td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--border-light);
    }
    
    table th {
      background: linear-gradient(to bottom, #f8f9fa, #f1f3f5);
      font-weight: 600;
      color: var(--text-color);
    }
    
    table tbody tr:hover {
      background-color: rgba(0,0,0,0.02);
    }
    
    table tbody tr:last-child td {
      border-bottom: none;
    }
    
    h1, h2, h3 {
      margin-top: 0;
      color: #1a202c;
      letter-spacing: -0.3px;
    }
    
    h2 {
      font-size: 1.75rem;
      margin-bottom: 0.6rem;
      font-weight: 600;
    }
    
    h3 {
      font-size: 1.35rem;
      margin-bottom: 1rem;
      font-weight: 600;
      color: #2d3748;
    }
        
    .subtitle {
      font-style: italic;
      color: #6c757d;
      margin-bottom: 1.8rem;
      font-size: 1.05rem;
      opacity: 0.85;
      border-bottom: 1px dashed rgba(0,0,0,0.08);
      padding-bottom: 0.8rem;
    }
        
    /* Styles needed by React component if not covered by Tailwind */
    .recharts-tooltip-wrapper {
      z-index: 1000 !important; /* Ensure tooltip is on top */
    }
    
    /* Loading spinner animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-spinner {
      width: 2.5rem;
      height: 2.5rem;
      border: 0.25rem solid rgba(0,0,0,0.1);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
      margin: 0.5rem auto;
    }
    
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(255,255,255,0.9);
      border-radius: var(--radius-sm);
      z-index: 10;
    }
    
    /* Animation controls for animated chart (from 2nd file) */
    .animation-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      background-color: #f1f3f5;
      border-radius: var(--radius-sm);
      margin-top: 1rem;
      border: 1px solid var(--border-light);
      gap: 0.75rem;
    }
    
    .animation-controls button {
      padding: 0.5rem 1rem;
      font-size: 0.95rem;
      border-radius: var(--radius-sm);
      border: 1px solid #dee2e6;
      background-color: var(--card-bg);
      color: var(--primary-color);
      cursor: pointer;
      transition: all var(--transition-fast);
      font-weight: 500;
    }
    
    .animation-controls button:hover {
      background-color: #f0f0f0;
    }
    
    .animation-controls button.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="container">
      <h1>Madias Creek Hydrologic Model & Uncertainty Dashboard</h1>
      <p>
        This dashboard visualizes how climate and land-use scenarios affect peak water outflow in Madias Creek, BC. 
        The model compares current conditions to 2050 projections under different scenarios: baseline climate change, 
        increased urban development, and replanting/restoration efforts across both moderate (2-year) and extreme (200-year) rainfall events.
      </p>
    </div>
  </header>
  
  <!-- Scroll to top button -->
  <button id="scrollTopBtn" style="position: fixed; bottom: 30px; right: 30px; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, var(--primary-color), #42a5f5); color: white; border: none; box-shadow: 0 3px 10px rgba(0,0,0,0.2); cursor: pointer; display: none; z-index: 1000; opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease;">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 19V5M5 12l7-7 7 7"/>
    </svg>
  </button>
  
  <main class="container">
    <div class="tab-links">
      <button class="tab-link active" id="tab-raw">Raw Outflow</button>
      <button class="tab-link" id="tab-distribution">Distribution Analysis</button>
      <button class="tab-link" id="tab-percentage">Percentage Change</button>
      <button class="tab-link" id="tab-trends">Trend Analysis</button>
    </div>
    
    <!-- Raw Outflow Tab (Chart.js) -->
    <div id="raw" class="tab-content active">
      <h2>Raw Max Outflow Comparison</h2>
      <p class="subtitle">Madias Creek Flow Analysis (100 Sample Average)</p>
      
      <div class="plot-description">
        The bar chart below shows the projected <b>maximum outflow</b> (peak water flow rate, in cubic meters per second) for Madias Creek, which flows through the ʔakisq̓nuk First Nation territory into Windermere Lake in southeastern British Columbia. Four modeling scenarios are compared:
        <ul>
          <li><b>Current (2020):</b> Current climate and land-use conditions in the Madias Creek watershed.</li>
          <li><b>2050 Baseline:</b> Year 2050 climate projection under baseline conditions (climate change only).</li>
          <li><b>Urban Development:</b> 2050 scenario with increased urban encroachment into floodplains (more impervious surfaces).</li>
          <li><b>Replanting:</b> 2050 scenario with ʔakisq̓nuk-led reforestation and wetland restoration projects.</li>
        </ul>
        Each scenario is evaluated for both <b>2-year</b> (common) and <b>200-year</b> (rare) return period events, under both <i>low-impact</i> and <i>high-impact</i> (peak) climate cases. Note the significant increase in flow rate for extreme events.
      </div>
      
      <p class="data-source-note">Source: Summary values representing multiple return periods</p>
      
      <div class="chart-container">
        <canvas id="rawChart"></canvas>
      </div>
    </div>
    
    <!-- Distribution Analysis Tab (React/Recharts) -->
    <div id="distribution" class="tab-content">
      <h2>Madias Creek Uncertainty Analysis</h2>
      <p class="subtitle">Statistical Distribution of Model Results (100 Runs)</p>
      
      <div class="plot-description">
        This visualization quantifies the <b>uncertainty</b> in our hydrologic model simulations for Madias Creek. Using LiDAR-derived elevation data and HEC-HMS modeling, we ran 100 simulations for each scenario to account for variability in:
        
        <ul>
          <li>Precipitation patterns (using data from Kootenay West Gate & Windermere Gauge Station)</li>
          <li>Soil infiltration rates across the watershed's diverse terrain</li>
          <li>Land cover changes under different management scenarios</li>
        </ul>
        
        The box plots show statistical distributions of outflow values, with each scenario's spread representing model uncertainty. The Current scenario shows the narrowest range, while future projections show wider spreads due to climate uncertainty. This analysis helps ʔakisq̓nuk First Nation and RDEK planners understand not just average effects but the full range of possible outcomes for flood management decisions.
      </div>
      
      <p class="data-source-note">Source: Full 100 samples from the uncertainty model runs</p>
      
      <!-- React component will render here -->
      <div id="distributionReactRoot"></div> 
    </div>
    
    <!-- Percentage Change Tab (Chart.js) -->
    <div id="percentage" class="tab-content">
      <h2>Percentage Change from 2050 Baseline</h2>
      <p class="subtitle">Madias Creek Management Impact Assessment</p>
      
      <div class="plot-description">
        This chart shows how the <b>Urban</b> and <b>Replanting</b> scenarios for Madias Creek differ from the 2050 Baseline climate projection. 
        Values are percentages relative to the baseline scenario (zero reference). 
        Positive percentages (red bars) indicate higher outflow than the baseline, while negative percentages (teal bars) indicate lower outflow. 
        
        <ul>
          <li>The Urban development scenario shows slight increases in peak flows (0.1-0.4%) due to increased impervious surfaces near the Highway 93/95 crossing.</li>
          <li>The ʔakisq̓nuk-led Replanting initiatives show meaningful reductions (1-5%) in outflow, with nature-based solutions proving most effective for smaller storm events.</li>
          <li>For 200-year extreme events, the mitigation impact of replanting is reduced but still meaningful (approximately 1% reduction).</li>
        </ul>
        
        These patterns align with the Regional District of East Kootenay (RDEK) flood management objectives and the BC Flood Strategy (2023).
      </div>
      
      <p class="data-source-note">Source: Calculated from summary values representing multiple return periods</p>
      
      <div class="chart-container">
        <canvas id="percentageChart"></canvas>
      </div>
    </div>
    
    <!-- Trend Analysis Tab (Chart.js) -->
    <div id="trends" class="tab-content">
      <h2>Trend Analysis: Madias Creek Climate Resilience</h2>
      <p class="subtitle">Comparison to Current Conditions by Return Period</p>
      
      <div class="plot-description">
        This visualization shows how climate change and land management strategies affect Madias Creek outflows across different rainfall event severities. The chart displays percentage increases relative to current conditions, highlighting:
        
        <ul>
          <li>The significant impact of climate change alone (baseline scenario) on all return periods, with a dramatic 38-40% increase for 200-year events.</li>
          <li>Even with replanting initiatives, all future scenarios show substantially higher peak flows than current conditions.</li>
          <li>The Urban scenario shows the highest increases, though the difference from baseline is minimal for extreme events.</li>
          <li>The difference between scenarios diminishes for more extreme events, suggesting limits to mitigation strategies during 200-year events.</li>
        </ul>
        
        This analysis supports ʔakisq̓nuk First Nation's focus on both mitigation (replanting) and adaptation (improved culverts at Highway 93/95) strategies, as identified in the watershed's vulnerability assessment.
      </div>
      
      <p class="data-source-note">Source: Calculated from summary values representing multiple return periods</p>
      
      <div class="chart-container">
        <canvas id="trendChart"></canvas>
      </div>
      
      <hr class="section-divider">
      
      <div class="grid" style="margin-top: 2rem;">
        <div class="card">
          <h3>Key Observations (Based on Averages)</h3>
          <ul>
            <li>The impact of <span class="font-semibold" style="color: #fd7e14;">climate change (2050 baseline)</span> increases with rainfall severity - showing significantly higher average outflow for 200-year events compared to current.</li>
            <li><span class="font-semibold" style="color: #17a2b8;">Replanting efforts</span> appear most effective at reducing average outflow during smaller events (2-year return periods).</li>
            <li><span class="font-semibold" style="color: #dc3545;">Urban development</span> generally increases average outflow, with potentially less *additional* impact relative to baseline at extreme events.</li>
            <li>All future scenarios show higher average outflow than current conditions, especially for extreme events.</li>
          </ul>
        </div>
        
        <div class="card">
          <h3>Implications</h3>
          <ul>
            <li>Planning for <span class="font-semibold">greater outflow capacity</span> is critical across all future scenarios.</li>
            <li>The most dramatic increases in average outflow occur between current conditions and the 2050 baseline.</li>
            <li>Mitigation strategies (like replanting) show diminishing returns as rainfall severity increases.</li>
            <li>Under 200-year peak events, average outflow under all future scenarios is substantially higher than current conditions.</li>
          </ul>
        </div>
      </div>
    </div>
  </main>
  
  <!-- Footer removed as requested -->

  <!-- Scroll to top button -->
  <button id="scrollTopBtn" style="position: fixed; bottom: 30px; right: 30px; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #1976d2, #42a5f5); color: white; border: none; box-shadow: 0 3px 10px rgba(0,0,0,0.2); cursor: pointer; display: none; z-index: 1000; opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease;">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 19V5M5 12l7-7 7 7"/>
    </svg>
  </button>
  
  <script>
    // Initialize data containers - will be filled from Excel
    window.rawOutflowData = []; // Will hold SUMMARY data for bar chart
    window.percentageChangeData = []; // Will hold SUMMARY data for bar chart
    window.trendData = []; // Will hold SUMMARY data for line chart
    window.boxPlotData = {}; // Will hold FULL data arrays for distribution analysis
    
    // Chart.js Instances (for non-React tabs)
    let rawChartInstance, percentageChartInstance, trendChartInstance;

    // --- Helper Function to find column name robustly ---
    function findColumnName(keys, keywords) {
        const lowerKeywords = keywords.map(k => k.toLowerCase());
        for (const key of keys) {
            const lowerKey = key.toLowerCase();
            if (lowerKeywords.some(kw => lowerKey.includes(kw))) {
                return key;
            }
        }
        console.warn(`Could not find column matching keywords: ${keywords.join(', ')} in keys: ${keys.join(', ')}`);
        return null; // Return null if no match found
    }

    // --- Helper Function to calculate average ---
    function calculateAverage(dataArray) {
        if (!dataArray || dataArray.length === 0) return 0;
        const sum = dataArray.reduce((acc, val) => acc + (Number(val) || 0), 0);
        return sum / dataArray.length;
    }

    // --- Load data from uncertainty.xlsx using XLSX library ---
    async function loadExcelData() {
      console.log("Attempting to load Excel data...");
      try {
        // Show loading indicators
        document.querySelectorAll('.chart-container').forEach(container => {
          // Store the original content
          const originalContent = container.innerHTML;
          // Create a loading overlay that preserves the original content
          const loadingDiv = document.createElement('div');
          loadingDiv.className = 'loading-overlay';
          loadingDiv.style.position = 'absolute';
          loadingDiv.style.top = '0';
          loadingDiv.style.left = '0';
          loadingDiv.style.width = '100%';
          loadingDiv.style.height = '100%';
          loadingDiv.style.display = 'flex';
          loadingDiv.style.justifyContent = 'center';
          loadingDiv.style.alignItems = 'center';
          loadingDiv.style.backgroundColor = 'rgba(255,255,255,0.8)';
          loadingDiv.style.zIndex = '10';
          loadingDiv.innerHTML = `
            <div style="text-align:center;">
              <div class="wave-loader" style="margin-bottom:15px;">
                <div></div><div></div><div></div><div></div><div></div>
              </div>
              <p>Loading data from Excel...</p>
            </div>
          `;
          
          // Add wave loader animation
          if (!document.getElementById('wave-loader-style')) {
            const style = document.createElement('style');
            style.id = 'wave-loader-style';
            style.textContent = `
              .wave-loader {
                display: flex;
                justify-content: center;
                align-items: flex-end;
                height: 40px;
              }
              .wave-loader > div {
                background-color: #2196f3;
                height: 100%;
                width: 5px;
                margin: 0 2px;
                border-radius: 3px;
                animation: wave 1.2s infinite ease-in-out;
              }
              .wave-loader > div:nth-child(2) { animation-delay: -1.1s; }
              .wave-loader > div:nth-child(3) { animation-delay: -1.0s; }
              .wave-loader > div:nth-child(4) { animation-delay: -0.9s; }
              .wave-loader > div:nth-child(5) { animation-delay: -0.8s; }
              @keyframes wave {
                0%, 40%, 100% { transform: scaleY(0.3); }
                20% { transform: scaleY(1); }
              }
            `;
            document.head.appendChild(style);
          }
          
          // Ensure the container has position relative for absolute positioning
          if (window.getComputedStyle(container).position === 'static') {
            container.style.position = 'relative';
          }
          
          container.appendChild(loadingDiv);
        });
        
        const response = await fetch('uncertainty.xlsx');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const arrayBuffer = await response.arrayBuffer();
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        
        console.log("Excel file loaded successfully. Sheets:", workbook.SheetNames);
        
        if (workbook.SheetNames.length === 0) {
          throw new Error("Excel file contains no sheets");
        }
        
        // Function to safely parse sheet to JSON and log issues
        const safeSheetToJson = (sheetName) => {
          const sheet = workbook.Sheets[sheetName];
          if (!sheet) {
            console.warn(`Sheet "${sheetName}" not found.`);
            return []; // Return empty array if sheet is missing
          }
          try {
            // Use header: 1 to get arrays, easier to find columns if header row isn't perfect
            const data = XLSX.utils.sheet_to_json(sheet, { header: 1 }); 
            if (data.length < 2) { // Need header row + at least one data row
                 console.warn(`Sheet "${sheetName}" has insufficient data (rows: ${data.length}).`);
                 return [];
            }
            // Convert array of arrays to array of objects using the first row as headers
            const headers = data[0].map(h => String(h).trim()); // Trim header names
            const jsonData = data.slice(1).map((row, index) => {
                const obj = { __rowNum__: index + 2 }; // Keep original row number if needed
                headers.forEach((header, i) => {
                    if (header) { // Only add if header is not empty
                         obj[header] = row[i];
                    }
                });
                return obj;
            });

            console.log(`Sheet "${sheetName}" parsed successfully. Rows: ${jsonData.length}`);
            if (jsonData.length > 0) {
              console.log(`Sheet "${sheetName}" first row keys:`, Object.keys(jsonData[0]));
            }
            return jsonData;
          } catch (e) {
            console.error(`Error parsing sheet "${sheetName}":`, e);
            return []; // Return empty array on parsing error
          }
        };

        // --- Load and Process Box Plot Data FIRST ---
        window.boxPlotData = {};
        const boxPlotSheetNames = {
            "2yr-low": "2yr max outflow - low",
            "2yr-peak": "2yr max outflow - peak",
            "200yr-low": "200yr max outflow - low",
            "200yr-peak": "200yr max outflow - peak"
        };
        
        const summaryData = {}; // To store calculated averages

        for (const [key, sheetName] of Object.entries(boxPlotSheetNames)) {
            let matchingSheet = workbook.SheetNames.find(name => name.toLowerCase() === sheetName.toLowerCase());
            
            if (matchingSheet) {
                console.log(`Processing sheet for boxplot/summary: "${matchingSheet}" (key: ${key})`);
                const sheetData = safeSheetToJson(matchingSheet);
                
                if (sheetData && sheetData.length > 0) {
                    const keys = Object.keys(sheetData[0]);
                    // Find column names robustly
                    const currentCol = findColumnName(keys, ['current', '2yr', '200yr']); // More flexible matching
                    const baselineCol = findColumnName(keys, ['base', 'baseline']);
                    const replantCol = findColumnName(keys, ['replant']);
                    const urbanCol = findColumnName(keys, ['urban']);

                    // Log found columns for debugging
                    console.log(`Columns found for ${key}: Current=${currentCol}, Baseline=${baselineCol}, Replant=${replantCol}, Urban=${urbanCol}`);

                    // Extract numeric data for boxplot
                    const extractNumeric = (colName) => {
                        if (!colName) return []; // Return empty if column not found
                        return sheetData.map(row => Number(row[colName])).filter(n => !isNaN(n));
                    };
                    
                    const currentData = extractNumeric(currentCol);
                    const baselineData = extractNumeric(baselineCol);
                    const replantData = extractNumeric(replantCol);
                    const urbanData = extractNumeric(urbanCol);

                    // Store full data for boxplot
                    window.boxPlotData[sheetName] = { // Use the actual sheet name as the key here
                        current: currentData,
                        baseline: baselineData,
                        replant: replantData,
                        urban: urbanData
                    };
                    console.log(`Boxplot data for ${sheetName} processed. Samples: Current=${currentData.length}, Baseline=${baselineData.length}, Replant=${replantData.length}, Urban=${urbanData.length}`);

                    // Calculate averages for summary charts
                    summaryData[key] = {
                        category: key.replace('-', ' ').replace('yr', '-Year ').replace('low', 'Low Avg').replace('peak', 'Peak Avg'), // e.g., "2-Year Low Avg"
                        Current: calculateAverage(currentData),
                        Baseline: calculateAverage(baselineData),
                        Replant: calculateAverage(replantData),
                        Urban: calculateAverage(urbanData)
                    };
                     console.log(`Summary averages for ${key}:`, summaryData[key]);

                } else {
                    console.warn(`No data found or parsed in sheet for ${sheetName}`);
                    window.boxPlotData[sheetName] = { current: [], baseline: [], replant: [], urban: [] };
                    summaryData[key] = { category: key, Current: 0, Baseline: 0, Replant: 0, Urban: 0 };
                }
            } else {
                console.warn(`No matching sheet found for "${sheetName}"`);
                window.boxPlotData[sheetName] = { current: [], baseline: [], replant: [], urban: [] };
                summaryData[key] = { category: key, Current: 0, Baseline: 0, Replant: 0, Urban: 0 };
            }
        }

        // --- Populate Summary Data Arrays ---
        // Order the summary data logically
        const orderedKeys = ["2yr-low", "2yr-peak", "200yr-low", "200yr-peak"];
        window.rawOutflowData = orderedKeys.map(key => summaryData[key]).filter(Boolean); // Use calculated averages
        
        // Calculate percentage change from summary data
        window.percentageChangeData = window.rawOutflowData.map(item => {
            const baseline = item.Baseline || 0;
            const urban = item.Urban || 0;
            const replant = item.Replant || 0;
            const urbanPct = baseline !== 0 ? ((urban - baseline) / baseline) * 100 : 0;
            const replantPct = baseline !== 0 ? ((replant - baseline) / baseline) * 100 : 0;
            
            return {
                category: item.category,
                Urban: urbanPct,
                Replant: replantPct
            };
        });

        // Calculate trend data from summary data
        window.trendData = window.rawOutflowData.map(item => {
            const current = item.Current || 0;
            const baseline = item.Baseline || 0;
            const replant = item.Replant || 0;
            const urban = item.Urban || 0;
            const baselineChange = current !== 0 ? ((baseline - current) / current) * 100 : 0;
            const replantChange = current !== 0 ? ((replant - current) / current) * 100 : 0;
            const urbanChange = current !== 0 ? ((urban - current) / current) * 100 : 0;
            
            return {
                name: item.category, // Use the category name for the x-axis label
                Current: 0, // Current is always 0% (reference point)
                Baseline: baselineChange,
                Replant: replantChange,
                Urban: urbanChange
            };
        });

        console.log("Final loaded and processed data structure:", {
          rawOutflowData: window.rawOutflowData,
          percentageChangeData: window.percentageChangeData,
          boxPlotData: window.boxPlotData,
          trendData: window.trendData
        });
        
        // Remove loading overlays
        document.querySelectorAll('.loading-overlay').forEach(overlay => overlay.remove());
        
        console.log("Excel data loading and processing finished successfully.");
        
      } catch (error) {
        console.error("Error loading or processing Excel data:", error);
        document.querySelectorAll('.chart-container').forEach(container => {
          // Remove any existing loading overlays
          container.querySelectorAll('.loading-overlay').forEach(overlay => overlay.remove());
          
          // Create an error overlay
          const errorDiv = document.createElement('div');
          errorDiv.className = 'error-overlay';
          errorDiv.style.position = 'absolute';
          errorDiv.style.top = '0';
          errorDiv.style.left = '0';
          errorDiv.style.width = '100%';
          errorDiv.style.height = '100%';
          errorDiv.style.display = 'flex';
          errorDiv.style.justifyContent = 'center';
          errorDiv.style.alignItems = 'center';
          errorDiv.style.backgroundColor = 'rgba(255,255,255,0.9)';
          errorDiv.style.color = 'red';
          errorDiv.style.zIndex = '10';
          errorDiv.innerHTML = `<p>Error loading data: ${error.message}. Please check console for details.</p>`;
          
          // Ensure the container has position relative for absolute positioning
          if (window.getComputedStyle(container).position === 'static') {
            container.style.position = 'relative';
          }
          
          container.appendChild(errorDiv);
        });
        
        // Ensure data variables are empty arrays if loading fails
        window.rawOutflowData = [];
        window.percentageChangeData = [];
        window.boxPlotData = {};
        window.trendData = [];
      }
      
      // Return true if boxplot data seems to have loaded (basic check)
      return window.boxPlotData && Object.keys(window.boxPlotData).length > 0; 
    }
    
    // --- Initialize charts and tabs ---
    document.addEventListener('DOMContentLoaded', function() {
      console.log("DOM fully loaded and parsed");
      const distributionTabContent = document.getElementById('distribution');
      const distributionReactRoot = document.getElementById('distributionReactRoot');
      let reactComponentMounted = false; // Track if React component is mounted

      // Load data first, then initialize tabs and default chart
      loadExcelData().then((dataLoaded) => {
        console.log("Excel data loading completed, dataLoaded check:", dataLoaded);
        
        // Initialize tabs after data load attempt
        const tabLinks = document.querySelectorAll('.tab-link');
        tabLinks.forEach(tab => {
          tab.addEventListener('click', function() {
            const tabId = this.id.replace('tab-', '');
            
            // Hide all tabs and remove active class from links
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            
            // Show the selected tab and mark link as active
            const activeContent = document.getElementById(tabId);
            if (activeContent) activeContent.classList.add('active');
            this.classList.add('active');
            
            // --- Chart Initialization / React Mounting ---
            // Use setTimeout to allow the DOM to update (tab becomes visible)
            setTimeout(() => {
                console.log(`Tab '${tabId}' selected, attempting updates.`);
                
                // Unmount React component if switching AWAY from distribution tab
                if (tabId !== 'distribution' && reactComponentMounted) {
                    if (distributionReactRoot.hasChildNodes()) {
                        console.log("Unmounting DistributionAnalysisComponent");
                        ReactDOM.unmountComponentAtNode(distributionReactRoot);
                        reactComponentMounted = false;
                    }
                }

                // Destroy existing Chart.js instances if switching AWAY from their tabs
                if (tabId !== 'raw' && rawChartInstance) { rawChartInstance.destroy(); rawChartInstance = null; console.log("Destroyed Raw Chart instance."); }
                if (tabId !== 'percentage' && percentageChartInstance) { percentageChartInstance.destroy(); percentageChartInstance = null; console.log("Destroyed Percentage Chart instance."); }
                if (tabId !== 'trends' && trendChartInstance) { trendChartInstance.destroy(); trendChartInstance = null; console.log("Destroyed Trend Chart instance."); }

                // Initialize/Mount based on the NOW ACTIVE tab
                const activeContent = document.getElementById(tabId); // Get the active tab content div
                if (!activeContent) {
                    console.error(`Could not find active content element for tab ID: ${tabId}`);
                    return; // Stop if the content container isn't found
                }

                if (tabId === 'raw') {
                    const canvasElement = activeContent.querySelector('#rawChart'); // Find canvas *within* active content
                    if (canvasElement) {
                        initializeRawChart(canvasElement); // Pass the canvas element
                    } else {
                        console.warn("Canvas element 'rawChart' not found within the active tab content.");
                    }
                } else if (tabId === 'percentage') {
                    const canvasElement = activeContent.querySelector('#percentageChart'); // Find canvas *within* active content
                    if (canvasElement) {
                        initializePercentageChart(canvasElement); // Pass the canvas element
                    } else {
                        console.warn("Canvas element 'percentageChart' not found within the active tab content.");
                    }
                } else if (tabId === 'trends') {
                    const canvasElement = activeContent.querySelector('#trendChart'); // Find canvas *within* active content
                    if (canvasElement) {
                        initializeTrendChart(canvasElement); // Pass the canvas element
                    } else {
                        console.warn("Canvas element 'trendChart' not found within the active tab content.");
                    }
                } else if (tabId === 'distribution') {
                    // Mount React component only if not already mounted
                    if (!reactComponentMounted) {
                        if (typeof window.DistributionAnalysisComponent !== 'undefined') {
                            // Check if boxPlotData seems valid before rendering
                            if (window.boxPlotData && Object.keys(window.boxPlotData).length > 0) {
                                console.log("Rendering DistributionAnalysisComponent with data prop:", window.boxPlotData);
                                // Pass the data as a prop
                                ReactDOM.render(React.createElement(window.DistributionAnalysisComponent, { initialData: window.boxPlotData }), distributionReactRoot);
                                reactComponentMounted = true;
                            } else {
                                console.warn("Attempted to render DistributionAnalysisComponent, but window.boxPlotData is not ready or empty.");
                                distributionReactRoot.innerHTML = '<p class="text-red-500">Distribution data is not available. Please check the data source and console logs.</p>';
                            }
                        } else {
                            console.error('DistributionAnalysisComponent not found. Babel might not have finished, or there was a script error.');
                            distributionReactRoot.innerHTML = '<p class="text-red-500">Error loading Distribution Analysis component. Check console logs.</p>';
                        }
                    } else {
                         console.log("DistributionAnalysisComponent already mounted.");
                    }
                }
            }, 150); // Increased delay ensures DOM is fully updated and visible
          });
        });
        
        // Initialize the default active tab's chart (Raw Outflow) IF data is loaded
        const initialActiveTabLink = document.querySelector('.tab-link.active');
        if (initialActiveTabLink) {
            const initialTabId = initialActiveTabLink.id.replace('tab-', '');
            const initialActiveContent = document.getElementById(initialTabId);

            if (initialActiveContent && initialTabId === 'raw') {
                 // Add a slightly longer delay for initial load
                 setTimeout(() => {
                    console.log("Attempting initial Raw Chart initialization after delay.");
                    const canvasElement = initialActiveContent.querySelector('#rawChart'); // Find canvas within initial active tab
                    if (canvasElement) {
                        initializeRawChart(canvasElement); // Pass the canvas element
                    } else {
                        console.warn("Canvas element 'rawChart' not found during initial load within the active tab.");
                    }
                 }, 250); // Increased delay to ensure canvas is fully rendered
            } else {
                console.log(`Initial load: Default active tab is '${initialTabId}', not 'raw'.`);
            }
        } else {
             console.warn("Initial load: Could not find default active tab link.");
        }
        
      }).catch(error => {
        console.error("Error during initial data load sequence:", error);
      });
      
    }); // End DOMContentLoaded

    // --- Chart.js Initialization Functions (now accept canvasElement) ---
    
    // Add global chart styling for consistent visuals
    Chart.defaults.font.family = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif";
    Chart.defaults.font.size = 12;
    Chart.defaults.color = '#495057';
    Chart.defaults.elements.line.tension = 0.2;
    Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(255, 255, 255, 0.95)';
    Chart.defaults.plugins.tooltip.titleColor = '#1a202c';
    Chart.defaults.plugins.tooltip.bodyColor = '#4a5568';
    Chart.defaults.plugins.tooltip.borderColor = 'rgba(0, 0, 0, 0.1)';
    Chart.defaults.plugins.tooltip.borderWidth = 1;
    Chart.defaults.plugins.tooltip.padding = 10;
    Chart.defaults.plugins.tooltip.cornerRadius = 8;
    Chart.defaults.plugins.tooltip.boxShadow = '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)';
    Chart.defaults.plugins.tooltip.boxPadding = 6;
    Chart.defaults.elements.point.radius = 4;
    Chart.defaults.elements.point.hoverRadius = 6;
    
    function initializeRawChart(canvasElement) {
        console.log("Attempting to initialize Raw Chart...");
        // Canvas element is now passed as an argument
        if (!canvasElement) {
             console.warn("initializeRawChart: Received null canvas element.");
             if (rawChartInstance) { rawChartInstance.destroy(); rawChartInstance = null; }
             return;
        }
        
        // Check if an instance already exists for this specific canvas
        if (rawChartInstance && rawChartInstance.canvas === canvasElement) {
            console.log("Raw Chart instance already exists for this canvas.");
            return; // Don't re-initialize if already present
        }
        // Destroy any old instance before creating a new one
        if (rawChartInstance) { rawChartInstance.destroy(); rawChartInstance = null; }

        const rawCtx = canvasElement.getContext('2d');
        if (!rawCtx) {
            console.warn("initializeRawChart: Failed to get 2D context from canvas.");
            return; 
        }
        // Check if data is loaded and valid
        if (!window.rawOutflowData || window.rawOutflowData.length === 0) {
            console.warn("Raw outflow summary data is not available or empty. Cannot initialize chart.");
            rawCtx.clearRect(0, 0, rawCtx.canvas.width, rawCtx.canvas.height);
            rawCtx.textAlign = 'center';
            rawCtx.fillText('Summary data not available', rawCtx.canvas.width / 2, rawCtx.canvas.height / 2);
            return;
        }
        
        console.log("Initializing Raw Chart with summary data:", window.rawOutflowData);
        
        try {
            rawChartInstance = new Chart(rawCtx, {
                type: 'bar',
                data: {
                labels: window.rawOutflowData.map(d => d.category),
                datasets: [
                    { label: 'Current Conditions', data: window.rawOutflowData.map(d => d.Current), backgroundColor: '#0056b3', borderRadius: 4 },
                    { label: '2050 Baseline (ViT)', data: window.rawOutflowData.map(d => d.Baseline), backgroundColor: '#fd7e14', borderRadius: 4 },
                    { label: 'Replanting Efforts', data: window.rawOutflowData.map(d => d.Replant), backgroundColor: '#17a2b8', borderRadius: 4 },
                    { label: 'Urban Development', data: window.rawOutflowData.map(d => d.Urban), backgroundColor: '#dc3545', borderRadius: 4 }
                ]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false,
                    animation: {
                        duration: 1500,
                        easing: 'easeOutQuart'
                    },
                    scales: { 
                        y: { 
                            beginAtZero: true, 
                            title: { 
                                display: true, 
                                text: 'Average Max Outflow (cms)',
                                font: {
                                    weight: '600',
                                    size: 13
                                },
                                padding: {bottom: 10}
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.04)',
                                drawBorder: false
                            },
                            ticks: {
                                padding: 8
                            }
                        },
                        x: {
                            ticks: {
                                autoSkip: false, // Prevent labels from being skipped
                                maxRotation: 45, // Rotate labels if needed
                                minRotation: 30,
                                padding: 10
                            },
                            grid: {
                                display: false
                            }
                        }
                    }, 
                    plugins: { 
                        tooltip: { 
                            callbacks: { 
                                label: function(context) { return `${context.dataset.label}: ${context.raw.toFixed(3)} cms`; } 
                            },
                            displayColors: true,
                            boxWidth: 8,
                            boxHeight: 8,
                            usePointStyle: true,
                            caretPadding: 5,
                            titleMarginBottom: 8
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 20,
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        }
                    } 
                }
            });
            console.log("Raw Chart initialized successfully.");
        } catch (error) {
            console.error("Error initializing Raw Chart:", error);
        }
    }

    function initializePercentageChart(canvasElement) {
        console.log("Attempting to initialize Percentage Chart...");
         if (!canvasElement) {
            console.warn("initializePercentageChart: Received null canvas element.");
             if (percentageChartInstance) { percentageChartInstance.destroy(); percentageChartInstance = null; }
            return; 
        }
        if (percentageChartInstance && percentageChartInstance.canvas === canvasElement) {
            console.log("Percentage Chart instance already exists.");
            return;
        }
        if (percentageChartInstance) { percentageChartInstance.destroy(); percentageChartInstance = null; }

        const percentageCtx = canvasElement.getContext('2d');
        if (!percentageCtx) {
            console.warn("initializePercentageChart: Failed to get 2D context.");
            return;
        }
       if (!window.percentageChangeData || window.percentageChangeData.length === 0) {
            console.warn("Percentage change summary data is not available or empty. Cannot initialize chart.");
            percentageCtx.clearRect(0, 0, percentageCtx.canvas.width, percentageCtx.canvas.height);
            percentageCtx.textAlign = 'center';
            percentageCtx.fillText('Summary data not available', percentageCtx.canvas.width / 2, percentageCtx.canvas.height / 2);
            return;
        }

        console.log("Initializing Percentage Chart with summary data:", window.percentageChangeData);

        try {
            // Determine min/max for y-axis dynamically, with some padding
            const allValues = window.percentageChangeData.flatMap(d => [d.Urban, d.Replant]);
            const dataMin = Math.min(...allValues);
            const dataMax = Math.max(...allValues);
            const yMin = Math.floor(dataMin - Math.abs(dataMin * 0.1)); // Add 10% padding below min
            const yMax = Math.ceil(dataMax + Math.abs(dataMax * 0.1)); // Add 10% padding above max

            percentageChartInstance = new Chart(percentageCtx, {
                type: 'bar',
                data: {
                labels: window.percentageChangeData.map(d => d.category),
                datasets: [
                    { label: 'Urban vs 2050', data: window.percentageChangeData.map(d => d.Urban), backgroundColor: '#dc3545', borderRadius: 4 },
                    { label: 'Replant vs 2050', data: window.percentageChangeData.map(d => d.Replant), backgroundColor: '#17a2b8', borderRadius: 4 }
                ]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { 
                        y: { 
                            title: { display: true, text: 'Change from Baseline (%)' }, 
                            ticks: { callback: function(value) { return value.toFixed(1) + '%'; } },
                            min: yMin, // Dynamic min
                            max: yMax  // Dynamic max
                        },
                        x: {
                            ticks: {
                                autoSkip: false, 
                                maxRotation: 45,
                                minRotation: 30
                            }
                        }
                    }, 
                    plugins: { 
                        tooltip: { 
                            callbacks: { 
                                label: function(context) { return `${context.dataset.label}: ${context.raw.toFixed(2)}%`; } 
                            } 
                        } 
                    } 
                }
            });
             console.log("Percentage Chart initialized successfully.");
        } catch (error) {
             console.error("Error initializing Percentage Chart:", error);
        }
    }

    function initializeTrendChart(canvasElement) {
        console.log("Attempting to initialize Trend Chart...");
        if (!canvasElement) {
            console.warn("initializeTrendChart: Received null canvas element.");
             if (trendChartInstance) { trendChartInstance.destroy(); trendChartInstance = null; }
            return;
        }
         if (trendChartInstance && trendChartInstance.canvas === canvasElement) {
            console.log("Trend Chart instance already exists.");
            return;
        }
        if (trendChartInstance) { trendChartInstance.destroy(); trendChartInstance = null; }

        const trendCtx = canvasElement.getContext('2d');
         if (!trendCtx) {
            console.warn("initializeTrendChart: Failed to get 2D context.");
            return;
        }
        if (!window.trendData || window.trendData.length === 0) {
            console.warn("Trend summary data is not available or empty. Cannot initialize chart.");
             trendCtx.clearRect(0, 0, trendCtx.canvas.width, trendCtx.canvas.height);
            trendCtx.textAlign = 'center';
            trendCtx.fillText('Summary data not available', trendCtx.canvas.width / 2, trendCtx.canvas.height / 2);
            return;
        }

        console.log("Initializing Trend Chart with summary data:", window.trendData);

        try {
             // Determine min/max for y-axis dynamically, ensuring 0 is included
            const allValues = window.trendData.flatMap(d => [d.Baseline, d.Replant, d.Urban]);
            const dataMin = Math.min(0, ...allValues); // Include 0
            const dataMax = Math.max(0, ...allValues); // Include 0
            const yMin = Math.floor(dataMin - Math.abs(dataMin * 0.1)); // Add 10% padding below min
            const yMax = Math.ceil(dataMax + Math.abs(dataMax * 0.1)); // Add 10% padding above max

            trendChartInstance = new Chart(trendCtx, {
                type: 'line',
                data: {
                labels: window.trendData.map(d => d.name),
                datasets: [
                    // Plot Baseline, Replant, Urban first
                     { label: '2050 Baseline (ViT)', data: window.trendData.map(d => d.Baseline), borderColor: '#fd7e14', backgroundColor: '#fd7e14', tension: 0.1, borderWidth: 3, pointRadius: 6, pointHoverRadius: 8 },
                    { label: 'Replanting Efforts', data: window.trendData.map(d => d.Replant), borderColor: '#17a2b8', backgroundColor: '#17a2b8', tension: 0.1, borderWidth: 3, pointRadius: 6, pointHoverRadius: 8 },
                    { label: 'Urban Development', data: window.trendData.map(d => d.Urban), borderColor: '#dc3545', backgroundColor: '#dc3545', tension: 0.1, borderWidth: 3, pointRadius: 6, pointHoverRadius: 8 },
                     // Plot Current (0 line) last so it's potentially on top visually if needed, though less critical for line
                    { label: 'Current Conditions', data: window.trendData.map(d => d.Current), borderColor: '#0056b3', backgroundColor: '#0056b3', tension: 0.1, borderWidth: 3, pointRadius: 6, pointHoverRadius: 8 },
                ]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { 
                        y: { 
                            title: { display: true, text: 'Change from Current (%)' }, 
                            ticks: { callback: function(value) { return value.toFixed(0) + '%'; } }, // Use 0 decimal places for cleaner axis
                            min: yMin, // Dynamic min
                            max: yMax  // Dynamic max
                        },
                        x: {
                             ticks: {
                                autoSkip: false, 
                                maxRotation: 45,
                                minRotation: 30
                            }
                        }
                    }, 
                    plugins: { 
                        tooltip: { 
                            callbacks: { 
                                label: function(context) { return `${context.dataset.label}: ${context.raw.toFixed(1)}%`; }, 
                                title: function(context) { return `${context[0].label}`; } // Use category name as title
                            } 
                        } 
                    } 
                }
            });
             console.log("Trend Chart initialized successfully.");
        } catch (error) {
            console.error("Error initializing Trend Chart:", error);
        }
    }
    
  </script>

  <!-- React Component Definition (using Babel for JSX) -->
  <script type="text/babel">
    const { useState, useEffect, useMemo } = React; // Added useMemo
    const { AreaChart, Area, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = Recharts;

    // --- Helper Functions (copied/adapted from modern-water-dashboard.jsx) ---
    const calculateStats = (data) => {
        if (!data || !Array.isArray(data) || data.length === 0) {
             // console.warn("calculateStats received invalid data:", data);
             return { min: NaN, max: NaN, q1: NaN, median: NaN, q3: NaN, avg: NaN };
        }
        const numericData = data.map(Number).filter(n => !isNaN(n)); // Ensure numeric
        if (numericData.length === 0) {
             // console.warn("calculateStats found no numeric data after filtering.");
             return { min: NaN, max: NaN, q1: NaN, median: NaN, q3: NaN, avg: NaN };
        }
        const sorted = [...numericData].sort((a, b) => a - b);
        const len = sorted.length;
        const min = sorted[0];
        const max = sorted[len - 1];
        // More robust quantile calculation (linear interpolation)
        const quantile = (p) => {
            const pos = (len - 1) * p;
            const base = Math.floor(pos);
            const rest = pos - base;
            if (sorted[base + 1] !== undefined) {
                return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
            } else {
                return sorted[base];
            }
        };
        const q1 = quantile(0.25);
        const median = quantile(0.5);
        const q3 = quantile(0.75);
        const avg = sorted.reduce((a, b) => a + b, 0) / len;
        
        return { min, max, q1, median, q3, avg };
    };

    // Calculate Y-axis range dynamically for EITHER low OR peak data
    const getDistributionYAxisRange = (yearGroup, allData, dataType) => { // Added dataType ('low' or 'peak')
        const targetKey = yearGroup === '2yr' 
            ? (dataType === 'low' ? "2yr max outflow - low" : "2yr max outflow - peak")
            : (dataType === 'low' ? "200yr max outflow - low" : "200yr max outflow - peak");

        let overallMin = Infinity;
        let overallMax = -Infinity;

        const updateMinMax = (dataArray) => {
             if (dataArray && dataArray.length > 0) {
                const numericData = dataArray.map(Number).filter(n => !isNaN(n));
                if (numericData.length > 0) {
                    // Use Math.min/max directly on the array elements
                    const currentMin = Math.min(...numericData);
                    const currentMax = Math.max(...numericData);
                    overallMin = Math.min(overallMin, currentMin);
                    overallMax = Math.max(overallMax, currentMax);
                }
            }
        };

        // Only process the relevant sheet data (low or peak)
        if (allData && allData[targetKey]) {
            updateMinMax(allData[targetKey].current);
            updateMinMax(allData[targetKey].baseline);
            updateMinMax(allData[targetKey].replant);
            updateMinMax(allData[targetKey].urban);
             console.log(`Range calculation for ${targetKey}: Min=${overallMin}, Max=${overallMax}`);
        } else {
             console.warn(`Data not found for key ${targetKey} during range calculation.`);
        }


        if (overallMin === Infinity || overallMax === -Infinity || isNaN(overallMin) || isNaN(overallMax)) {
            // Fallback if no valid data found
             console.warn(`Could not determine valid min/max for ${targetKey}. Using fallback range.`);
            return yearGroup === '2yr' 
                   ? (dataType === 'low' ? [1.0, 1.5] : [2.0, 2.6]) // Tighter fallbacks
                   : (dataType === 'low' ? [7.0, 12.0] : [15.0, 24.0]); // Tighter fallbacks
        }

        // Add some padding (e.g., 15% of the range)
        const range = overallMax - overallMin;
        // Handle case where min and max are the same
        const padding = range === 0 ? overallMax * 0.15 || 0.1 : range * 0.15; 
        
        // Ensure minimum is not negative unless data actually goes below zero
        let domainMin = overallMin - padding;
        if (overallMin >= 0) {
             domainMin = Math.max(0, domainMin); // Cap at 0 if all data is non-negative
        }
        let domainMax = overallMax + padding;

        // Round appropriately for display (e.g., to one decimal place)
        domainMin = Math.floor(domainMin * 10) / 10; 
        domainMax = Math.ceil(domainMax * 10) / 10; 

        // Ensure min is strictly less than max
        if (domainMin >= domainMax) {
             domainMax = domainMin + 0.1; // Add a small amount if they ended up equal
        }

        console.log(`Calculated Y-axis range for ${targetKey}: [${domainMin}, ${domainMax}]`);
        return [domainMin, domainMax];
    };

    // Update function signature to accept data as argument
    const generateAreaDistributionData = (yearGroup, boxPlotData) => { 
        // Map yearGroup to the correct sheet names/keys
        const lowKey = yearGroup === '2yr' ? "2yr max outflow - low" : "200yr max outflow - low";
        const peakKey = yearGroup === '2yr' ? "2yr max outflow - peak" : "200yr max outflow - peak";

        // Check if the passed boxPlotData and the required keys exist and contain data
         if (!boxPlotData || !boxPlotData[lowKey] || !boxPlotData[peakKey] ||
             !boxPlotData[lowKey].current || !boxPlotData[peakKey].current ) { // Basic check for existence
            console.warn(`generateAreaDistributionData: Box plot data for keys '${lowKey}' or '${peakKey}' not found or incomplete in passed data.`);
            return [{ group: "Low", data: [] }, { group: "Peak", data: [] }];
        }

        // Calculate stats on the numerical arrays stored in boxPlotData
        const lowStats = {
            current: calculateStats(boxPlotData[lowKey].current),
            baseline: calculateStats(boxPlotData[lowKey].baseline),
            replant: calculateStats(boxPlotData[lowKey].replant),
            urban: calculateStats(boxPlotData[lowKey].urban)
        };
        
        const peakStats = {
            current: calculateStats(boxPlotData[peakKey].current),
            baseline: calculateStats(boxPlotData[peakKey].baseline),
            replant: calculateStats(boxPlotData[peakKey].replant),
            urban: calculateStats(boxPlotData[peakKey].urban)
        };
        
        // Map stats to the format needed by the chart
        const mapData = (stats, type) => ([
            { name: 'Current', ...stats.current, type },
            { name: '2050 Baseline', ...stats.baseline, type }, // Match name used elsewhere
            { name: 'Replant', ...stats.replant, type }, // Match name used elsewhere
            { name: 'Urban', ...stats.urban, type } // Match name used elsewhere
        ]);

        return [
            { group: "Low", data: mapData(lowStats, "Low") },
            { group: "Peak", data: mapData(peakStats, "Peak") }
        ];
    };

    // --- React Component for Distribution Tab ---
    function DistributionAnalysisComponent(props) { // Accept props
        const { initialData } = props; // Destructure the passed data
        const [selectedYearGroup, setSelectedYearGroup] = useState('2yr');
        const [chartHover, setChartHover] = useState(null); // Optional hover state
        
        // Memoize data generation and axis range calculation
        const { areaDistributionData, yAxisRangeLow, yAxisRangePeak, isDataReady } = useMemo(() => {
            const lowKey = selectedYearGroup === '2yr' ? "2yr max outflow - low" : "200yr max outflow - low";
            const peakKey = selectedYearGroup === '2yr' ? "2yr max outflow - peak" : "200yr max outflow - peak";
            
            // More robust check: ensure the keys exist and the arrays within have length > 0
            const dataAvailable = initialData && 
                                initialData[lowKey] && 
                                initialData[peakKey] &&
                                Array.isArray(initialData[lowKey].current) && initialData[lowKey].current.length > 0 &&
                                Array.isArray(initialData[lowKey].baseline) && initialData[lowKey].baseline.length > 0 &&
                                Array.isArray(initialData[lowKey].replant) && initialData[lowKey].replant.length > 0 &&
                                Array.isArray(initialData[lowKey].urban) && initialData[lowKey].urban.length > 0 &&
                                Array.isArray(initialData[peakKey].current) && initialData[peakKey].current.length > 0 &&
                                Array.isArray(initialData[peakKey].baseline) && initialData[peakKey].baseline.length > 0 &&
                                Array.isArray(initialData[peakKey].replant) && initialData[peakKey].replant.length > 0 &&
                                Array.isArray(initialData[peakKey].urban) && initialData[peakKey].urban.length > 0;

            if (!dataAvailable) {
                 console.warn(`Distribution data for keys '${lowKey}' or '${peakKey}' is not ready or incomplete in initialData.`);
                 // Provide default ranges even when data is not ready
                 const defaultRangeLow = getDistributionYAxisRange(selectedYearGroup, null, 'low');
                 const defaultRangePeak = getDistributionYAxisRange(selectedYearGroup, null, 'peak');
                 return { 
                     areaDistributionData: [{ group: "Low", data: [] }, { group: "Peak", data: [] }], 
                     yAxisRangeLow: defaultRangeLow, 
                     yAxisRangePeak: defaultRangePeak, 
                     isDataReady: false 
                 };
            }

            console.log(`Distribution data for keys '${lowKey}' and '${peakKey}' appears ready. Generating chart data.`);
            const generatedData = generateAreaDistributionData(selectedYearGroup, initialData);
            // Calculate separate ranges for low and peak
            const rangeLow = getDistributionYAxisRange(selectedYearGroup, initialData, 'low'); 
            const rangePeak = getDistributionYAxisRange(selectedYearGroup, initialData, 'peak'); 
            return { 
                areaDistributionData: generatedData, 
                yAxisRangeLow: rangeLow, 
                yAxisRangePeak: rangePeak, 
                isDataReady: true 
            };

        }, [selectedYearGroup, initialData]); // Recalculate only when these change

        const DistributionTooltip = ({ active, payload, label }) => {
            if (active && payload && payload.length) {
                // Find the payload associated with the Area or Line (not just the hovered point)
                const dataPoint = payload.find(p => p.payload); // Find first payload with a 'payload' property
                if (!dataPoint || !dataPoint.payload) return null; 
                
                const data = dataPoint.payload; // Access the data point object
                
                // Check if data properties exist before accessing them
                if (!data || data.min === undefined || isNaN(data.min)) return null; 
                
                return (
                    <div className="bg-white p-3 rounded shadow-lg border border-gray-200 text-xs" style={{ zIndex: 1100 }}> {/* Ensure high z-index */}
                        <div className="font-semibold text-gray-800 mb-1">{data.name} - {data.type}</div>
                        <div className="space-y-1">
                            <div>Min: {data.min?.toFixed(3)} cms</div>
                            <div>Q1 (25%): {data.q1?.toFixed(3)} cms</div>
                            <div className="font-medium">Median (50%): {data.median?.toFixed(3)} cms</div>
                            <div>Q3 (75%): {data.q3?.toFixed(3)} cms</div>
                            <div>Max: {data.max?.toFixed(3)} cms</div>
                            <div className="font-medium">Average: {data.avg?.toFixed(3)} cms</div>
                        </div>
                    </div>
                );
            }
            return null;
        };
        
        // Display loading or error message if data isn't ready
        if (!isDataReady) {
             const lowKey = selectedYearGroup === '2yr' ? "2yr max outflow - low" : "200yr max outflow - low";
             const peakKey = selectedYearGroup === '2yr' ? "2yr max outflow - peak" : "200yr max outflow - peak";
             let message = `Loading data or data unavailable for the ${selectedYearGroup === '2yr' ? '2-Year' : '200-Year'} period...`;
             if (!initialData) {
                 message = `Data not passed correctly to the component. Check console logs.`;
             } else {
                  message = `Data unavailable. Please ensure the 'uncertainty.xlsx' file contains valid numeric data in the expected columns for sheets: '${lowKey}' and '${peakKey}'. Check console for details.`;
             }

             return (
                <div>
                    <h2 className="text-xl font-semibold text-gray-800 mb-1">Distribution Analysis</h2>
                    <p className="text-red-600 bg-red-100 p-3 rounded border border-red-300 mb-4 text-sm italic">{message}</p>
                     {/* Still show selectors */}
                     <div className="flex flex-wrap mb-6">
                        <button 
                            onClick={() => setSelectedYearGroup('2yr')} 
                            className={`px-4 py-2 mr-2 mb-2 text-sm rounded-md transition-colors ${
                            selectedYearGroup === '2yr' 
                                ? 'bg-blue-700 text-white' 
                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                            }`}
                        >
                            2-Year Return Period
                        </button>
                        <button 
                            onClick={() => setSelectedYearGroup('200yr')} 
                            className={`px-4 py-2 mb-2 text-sm rounded-md transition-colors ${
                            selectedYearGroup === '200yr' 
                                ? 'bg-blue-700 text-white' 
                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                            }`}
                        >
                            200-Year Return Period
                        </button>
                    </div>
                </div>
            );
        }

        return (
            <div>
                <h2 className="text-xl font-semibold text-gray-800 mb-1">
                    Distribution Analysis ({selectedYearGroup === '2yr' ? '2-Year' : '200-Year'} Return Period)
                </h2>
                <p className="text-gray-600 mb-4 text-sm italic">Distribution across 100 samples</p>
                
                {/* Period selector */}
                <div className="flex flex-wrap mb-6">
                    <button 
                        onClick={() => setSelectedYearGroup('2yr')} 
                        className={`px-4 py-2 mr-2 mb-2 text-sm rounded-md transition-colors ${
                        selectedYearGroup === '2yr' 
                            ? 'bg-blue-700 text-white' 
                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                        }`}
                    >
                        2-Year Return Period
                    </button>
                    <button 
                        onClick={() => setSelectedYearGroup('200yr')} 
                        className={`px-4 py-2 mb-2 text-sm rounded-md transition-colors ${
                        selectedYearGroup === '200yr' 
                            ? 'bg-blue-700 text-white' 
                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                        }`}
                    >
                        200-Year Return Period
                    </button>
                </div>
                
                <div 
                    className="bg-blue-50 p-4 rounded-lg mb-6 border-l-4 border-blue-500"
                    onMouseEnter={() => setChartHover('dist')}
                    onMouseLeave={() => setChartHover(null)}
                >
                    <p className={`transition-opacity duration-300 ${chartHover === 'dist' ? 'opacity-100' : 'opacity-70'} text-sm`}>
                        This chart visualizes the statistical distribution (min, max, quartiles, median, average) of max outflow values 
                        for both low and peak events in the {selectedYearGroup === '2yr' ? '2-year' : '200-year'} return period, based on 100 samples per scenario.
                    </p>
                </div>

                {/* Legend - Updated */}
                <div className="flex items-center justify-center mb-6 text-xs text-gray-600 flex-wrap">
                    <div className="flex items-center mr-4 mb-2">
                        <div className="w-4 h-4 bg-blue-200 opacity-60 mr-1 border border-blue-400"></div> {/* Example for Low */}
                        <div className="w-4 h-4 bg-red-200 opacity-60 mr-1 border border-red-400"></div> {/* Example for Peak */}
                        <span>= 25%-75% Quartiles</span>
                    </div>
                    <div className="flex items-center mr-4 mb-2">
                         <div className="w-4 h-px bg-blue-700 mx-1"></div> {/* Example for Low */}
                         <div className="w-4 h-px bg-red-700 mx-1"></div> {/* Example for Peak */}
                        <span>= Median</span>
                    </div>
                    <div className="flex items-center mr-4 mb-2">
                        <div className="w-2 h-2 rounded-full bg-blue-500 mr-1"></div> {/* Example for Low */}
                        <div className="w-2 h-2 rounded-full bg-red-500 mr-1"></div> {/* Example for Peak */}
                        <span>= Average</span>
                    </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    {/* Low Event Chart - Refactored */}
                    <div>
                        <h3 className="text-lg font-medium text-center mb-2 text-gray-700">Low Events</h3>
                        <div className="h-80">
                            <ResponsiveContainer width="100%" height="100%">
                                <AreaChart
                                    data={areaDistributionData[0].data}
                                    margin={{ top: 5, right: 20, left: 15, bottom: 5 }} // Adjusted left margin
                                >
                                    <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                                    <XAxis dataKey="name" tick={{ fontSize: 10 }} interval={0} />
                                    <YAxis 
                                        domain={yAxisRangeLow} // Use specific range for Low chart
                                        label={{ value: `Max Outflow (cms)`, angle: -90, position: 'insideLeft', style: { textAnchor: 'middle', fontSize: 11 }, dx:-15 }} // Adjusted dx
                                        tick={{ fontSize: 10 }}
                                        tickFormatter={(val) => val.toFixed(1)}
                                        allowDataOverflow={true} // Prevent clipping of area/line near boundaries
                                        width={40} // Explicit width for YAxis
                                    />
                                    <Tooltip content={<DistributionTooltip />} wrapperStyle={{ zIndex: 1100 }} />
                                    
                                    {/* Area for Q1-Q3 Range */}
                                    <Area 
                                        type="monotone" 
                                        dataKey={d => [d.q1, d.q3]} // Use accessor function for range
                                        stroke="none" 
                                        fill="rgba(0,86,179,0.2)" // Blue fill for low events
                                        fillOpacity={0.6}
                                        name="Quartile Range (Q1-Q3)"
                                        isAnimationActive={false} // Disable animation for range area
                                    />

                                    {/* Median Line */}
                                    <Line 
                                        type="monotone" 
                                        dataKey="median" 
                                        stroke="#0056b3" // Darker blue for median
                                        strokeWidth={2} 
                                        dot={false} 
                                        activeDot={false} 
                                        name="Median"
                                        isAnimationActive={true} 
                                    />
                                    
                                    {/* Average Dot (using Line with only dots) */}
                                    <Line 
                                        type="monotone" 
                                        dataKey="avg" 
                                        stroke="transparent" // Hide the line itself
                                        dot={{ r: 4, fill: '#2196F3', strokeWidth: 1, stroke: '#0056b3' }}
                                        activeDot={{ r: 6 }}
                                        name="Average"
                                        isAnimationActive={true} 
                                    />
                                </AreaChart>
                            </ResponsiveContainer>
                        </div>
                    </div>
                    
                    {/* Peak Event Chart - Refactored */}
                    <div>
                        <h3 className="text-lg font-medium text-center mb-2 text-gray-700">Peak Events</h3>
                        <div className="h-80">
                            <ResponsiveContainer width="100%" height="100%">
                                <AreaChart
                                    data={areaDistributionData[1].data}
                                    margin={{ top: 5, right: 20, left: 15, bottom: 5 }} // Adjusted left margin
                                >
                                    <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                                    <XAxis dataKey="name" tick={{ fontSize: 10 }} interval={0} />
                                    <YAxis 
                                        domain={yAxisRangePeak} // Use specific range for Peak chart
                                        label={{ value: `Max Outflow (cms)`, angle: -90, position: 'insideLeft', style: { textAnchor: 'middle', fontSize: 11 }, dx:-15 }} // Adjusted dx
                                        tick={{ fontSize: 10 }}
                                        tickFormatter={(val) => val.toFixed(1)}
                                        allowDataOverflow={true} // Prevent clipping
                                        width={40} // Explicit width
                                    />
                                     <Tooltip content={<DistributionTooltip />} wrapperStyle={{ zIndex: 1100 }} />
                                    
                                    {/* Area for Q1-Q3 Range */}
                                    <Area 
                                        type="monotone" 
                                        dataKey={d => [d.q1, d.q3]} // Use accessor function
                                        stroke="none" 
                                        fill="rgba(220,53,69,0.2)" // Red fill for peak events
                                        fillOpacity={0.6}
                                        name="Quartile Range (Q1-Q3)"
                                        isAnimationActive={false}
                                    />

                                    {/* Median Line */}
                                    <Line 
                                        type="monotone" 
                                        dataKey="median" 
                                        stroke="#dc3545" // Darker red for median
                                        strokeWidth={2} 
                                        dot={false} 
                                        activeDot={false} 
                                        name="Median"
                                        isAnimationActive={true}
                                    />
                                    
                                    {/* Average Dot */}
                                    <Line 
                                        type="monotone" 
                                        dataKey="avg" 
                                        stroke="transparent" 
                                        dot={{ r: 4, fill: '#dc3545', strokeWidth: 1, stroke: '#b02a37' }}
                                        activeDot={{ r: 6 }}
                                        name="Average"
                                        isAnimationActive={true}
                                    />
                                </AreaChart>
                            </ResponsiveContainer>
                        </div>
                    </div>
                </div>
                
                {/* Statistics and Insights */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-8">
                    <div className="bg-gray-100 p-4 rounded-lg">
                        <h3 className="font-semibold text-lg mb-2 text-gray-800">Key Statistics (Calculated from Samples)</h3>
                        <div className="overflow-x-auto">
                            <table className="min-w-full bg-white rounded-lg overflow-hidden text-xs">
                                <thead className="bg-gray-200">
                                <tr>
                                    <th className="px-3 py-2 text-left font-semibold text-gray-700">Scenario</th>
                                    <th className="px-3 py-2 text-left font-semibold text-gray-700">Type</th>
                                    <th className="px-3 py-2 text-left font-semibold text-gray-700">Min</th>
                                    <th className="px-3 py-2 text-left font-semibold text-gray-700">Max</th>
                                    <th className="px-3 py-2 text-left font-semibold text-gray-700">Average</th>
                                    <th className="px-3 py-2 text-left font-semibold text-gray-700">Median</th>
                                </tr>
                                </thead>
                                <tbody>
                                {areaDistributionData[0].data.map((item, index) => (
                                    <tr key={`low-${index}`} className={index % 2 === 0 ? 'bg-gray-50' : 'bg-white'}>
                                    <td className="px-3 py-2 text-gray-800 font-medium">{item.name}</td>
                                    <td className="px-3 py-2 text-gray-800">Low</td>
                                    <td className="px-3 py-2 text-gray-800">{item.min?.toFixed(3)}</td>
                                    <td className="px-3 py-2 text-gray-800">{item.max?.toFixed(3)}</td>
                                    <td className="px-3 py-2 text-gray-800 font-semibold">{item.avg?.toFixed(3)}</td>
                                    <td className="px-3 py-2 text-gray-800">{item.median?.toFixed(3)}</td>
                                    </tr>
                                ))}
                                {areaDistributionData[1].data.map((item, index) => (
                                    <tr key={`peak-${index}`} className={index % 2 === 1 ? 'bg-gray-50' : 'bg-white'}>
                                    <td className="px-3 py-2 text-gray-800 font-medium">{item.name}</td>
                                    <td className="px-3 py-2 text-gray-800">Peak</td>
                                    <td className="px-3 py-2 text-gray-800">{item.min?.toFixed(3)}</td>
                                    <td className="px-3 py-2 text-gray-800">{item.max?.toFixed(3)}</td>
                                    <td className="px-3 py-2 text-gray-800 font-semibold">{item.avg?.toFixed(3)}</td>
                                     <td className="px-3 py-2 text-gray-800">{item.median?.toFixed(3)}</td>
                                    </tr>
                                ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div className="bg-gray-100 p-4 rounded-lg">
                        <h3 className="font-semibold text-lg mb-2 text-gray-800">Key Insights</h3>
                        {selectedYearGroup === '2yr' ? (
                        <ul className="list-disc pl-5 space-y-2 text-sm text-gray-800">
                            <li>The <span className="font-medium">Urban</span> scenario shows the highest average peak flow values (~{areaDistributionData[1].data.find(d=>d.name==='Urban')?.avg?.toFixed(2)} cms).</li>
                            <li>The <span className="font-medium">Current</span> conditions have the lowest average outflow values across both low (~{areaDistributionData[0].data.find(d=>d.name==='Current')?.avg?.toFixed(2)} cms) and peak events (~{areaDistributionData[1].data.find(d=>d.name==='Current')?.avg?.toFixed(2)} cms).</li>
                            <li>The <span className="font-medium">Replant</span> strategy shows noticeable reduction compared to Baseline, especially for peak events.</li>
                            <li>The distribution (spread between min/max and quartiles) varies between scenarios.</li>
                        </ul>
                        ) : (
                        <ul className="list-disc pl-5 space-y-2 text-sm text-gray-800">
                            <li>All future scenarios show dramatically higher average values compared to current conditions for 200-year events.</li>
                            <li>The <span className="font-medium">Replant</span> scenario offers some reduction compared to Baseline, but the overall outflow remains high.</li>
                            <li>The relative impact of <span className="font-medium">Urban</span> development vs Baseline might be less pronounced during these extreme events compared to 2-year events.</li>
                            <li>The gap between low and peak values, and the overall range of values, is much wider than in 2-year return periods.</li>
                        </ul>
                        )}
                    </div>
                </div>
            </div>
        );
    }
    
    // Make the component globally available for the main script
    window.DistributionAnalysisComponent = DistributionAnalysisComponent;
    
    // When document is fully loaded, initialize scroll to top button
    document.addEventListener('DOMContentLoaded', function() {
      // Scroll to top button functionality
      const scrollTopBtn = document.getElementById('scrollTopBtn');
      
      window.addEventListener('scroll', function() {
        if (document.documentElement.scrollTop > 300) {
          scrollTopBtn.style.display = 'block';
          setTimeout(() => {
            scrollTopBtn.style.opacity = '1';
            scrollTopBtn.style.transform = 'translateY(0)';
          }, 10);
        } else {
          scrollTopBtn.style.opacity = '0';
          scrollTopBtn.style.transform = 'translateY(10px)';
          setTimeout(() => {
            if (document.documentElement.scrollTop <= 300) {
              scrollTopBtn.style.display = 'none';
            }
          }, 300);
        }
      });
      
      scrollTopBtn.addEventListener('click', function() {
        window.scrollTo({
          top: 0,
          behavior: 'smooth'
        });
      });
    });

  </script>
</body>
</html>